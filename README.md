# kernel

> 内核学习和相关知识点整理

## 文档

- [Intel基础知识](doc/intel.md)
- [汇编](doc/汇编.md)
- [BIOS](doc/BIOS.md)
- [80386内存管理](doc/80386内存管理.md)

### 各个内核版本
- [kernel v0.0.0](doc/kernel-v0.0.0.md)
- [kernel v0.1.1](doc/kernel-v0.1.1.md)


# kernel-0.0.0

取赵炯老师的源码编译[http://oldlinux.org/Linux.old/bochs/linux-0.00-050613.zip](http://oldlinux.org/Linux.old/bochs/linux-0.00-050613.zip)

编译成功后会在 bochs 里交替输出 A 和 B，生成的 Image镜像中包含了操作系统引导部分`boot`和系统主体部分`system`。

## 问题
- [ ] 目前使用 `objcopy -O binary` 转换后的 head 文件太大，导致生成的最终 Image 太大，目前还想不到解决方法。**ELF文件转为纯二进制文件后，怎么去掉无用内容?**


## 引导(启动)系统

1. **当PC的电源打开后，80x86结构的CPU将自动进入实模式，并从地址0xFFFF0开始自动执行程序代码，这个地址通常是ROM-BIOS中的地址。**PC机的BIOS将执行某些系统的检测，在物理地址0处开始初始化中断向量。此后，它将可启动设备的第一个扇区读入内存地址0x7C00(31.744 kb)处，并跳转到这个地方。启动设备通常是软驱或是硬盘。
2. Linux的最最前面部分是用8086汇编语言编写的(boot/bootsect.S)，它将由BIOS读入到内存0x7C00处，当它被执行时就会把自己移到绝对地址0x90000处，并将启动设备(boot/setup.S)的下2kB字节的代码读入内存0x90200处，而内核的其它部分则被读入到地址0x10000处。在系统加载期间将显示信息"Loading..."。然后控制权将传递给boot/Setup.S中的代码，这是另一个实模式汇编语言程序。 
3. 启动部分识别主机的某些特性以及vga卡的类型。如果需要，它会要求用户为控制台选择显示模式。然后将整个系统从地址0x10000移至0x1000处，进入保护模式并跳转至系统的余下部分（在0x1000处）。 
4. 下一步是内核的解压缩。0x1000处的代码来自于zBoot/head.S，它初始化寄存器并调用decompress_kernel()，它们依次是由zBoot/inflate.c、zBoot/unzip.c和zBoot/misc.c组成。被解压的数据存放到了地址0x10000处(1兆)，这也是为什么Linux不能运行于少于2兆内存的主要原因。
5. 解压过的代码是从地址0x10100处开始执行的[这里我可能忘记了具体的物理地址了，因为我对相应的代码不是很熟]，在那里，所有32比特的设置启动被完成: IDT、GDT以及LDT被加载，处理器和协处理器也已确认，分页工作也设置好了；最终调用start_kernel子程序。上述操作的源代码是在boot/head.S中的，这可能是整个内核中最有诀窍的代码了。
> 注意如果在前述任何一步中出了错，计算机就会死锁。在操作系统还没有完全运转之前是处理不了出错的。
6. start_kernel()是位于init/main.c中的，并且没有任何返回结果。从现在起的任何代码都是用C语言编制的，除了中断管理和系统调用的入/出代码（当然，还有大多数的宏都嵌入了汇编代码）。 
7. 在处理了所有错综复杂的问题之后，start_kernel()初始化了内核的所有部分，尤其是: 
- 设置内存边界和调用paging_init()； 
- 初始化中断、IRQ通道和调度； 
- 分析（解析）命令行； 
- 如果需要，就分配一个数据缓冲区(profiling buffer)以及其它一些小部分； 
- 校正延迟循环（计算“BogoMips”数)； 
- 检查中断16是否能与协处理器工作。 
最后，为了生成初始进程，内核准备好了移至move_to_user_mode()，它的代码也是在同一个源代码文件中的。然后，所谓的空闲任务，进程号0就进入无限的空闲循环中运行。
8. 接着初始进程（init process）尝试着运行`/etc/init`、`/bin/init`或者`/sbin/init`。如果它们没有一个运行成功的，就会去执行代码“/bin/sh /etc/rc”并且在第一个终端上生成一个根命令解释程序（root shell）。这段代码回溯至Linux 0.01，当时操作系统只有一个内核，并且没有登录进程。 
9. 用exec()执行了init初始化程序之后，内核就对程序的执行没有了直接的控制。从现在起它的规则是提供对系统调用的处理，以及为异步事件服务（比如硬件中断等）。多任务的环境已经建立，从现在起是init程序通过fork()派生出的系统进程和登录进程来管理多用户的访问了。 



